/**                                                                    **\
**  Copyright (c) 2018-2019 Center for Organic and Medicinal Chemistry  **
**                Zurich University of Applied Sciences                 **
**                Wädenswil, Switzerland                                **
\**                                                                    **/

package cyby
package server

import cyby.dat._
import cats.Eq, cats.implicits.{none ⇒ _, _}

/**
  * This trait provides the core functionality for
  * adding, updating, and deleting objects in a data tree.
  *
  * However, this trait is not trivial to use and requires
  * some introductory remarks.
  *
  * First and foremost, the trait defines many abstract types.
  * They are the key to facilitate writing correct and
  * easily testable function implementations.
  *
  * In order to understand the process of editing stuff in the
  * data tree, consider the following example:
  *
  * Adding a new data object leads to the following steps being
  * executed:
  *
  *   - client sents request for adding. this consists of
  *     the required values of the new data object
  *     (represented by type {{Add}}) and a path object leading
  *     to the new data object's parent in the data tree
  *     (represented by type {{ParentPath}}).
  *
  *   - after collecting all information necessary to perform the
  *     mutation (represented by type {{Env}}), function {{fullEd}}
  *     is called. {{Env}} typically holds information about the
  *     user making the call, the actual state of the data tree
  *     and other pieces of information necessary to authorize
  *     the calling user and validate the fields of the new
  *     data object.
  *
  *   - the new data object's parent object is looked up (this might
  *     fail if it does no longer exist), resulting in an instance
  *     of {{EdSt}}. All environments used for authorization and
  *     validation are now assembled.
  *
  *   - the calling user is authorized changing the data object's type
  *     from {{Add}} to {{Add @@ Authorized}}
  *
  *   - the new data object is validated changing its type from
  *     {{Add @@ Authorized}} to {{Add @@ IsValid}}
  *
  *   - Using the environments, fields missing from the new data object
  *     (like its ID, time of creation and probably other things like
  *     molecular fingerprints) are being created. Its type changes
  *     from {{Add @@ IsValid}} to {{SrvAdd @@ IsValid}}.
  *
  *   - A new in-memory data object is being created (type: {{Srv @@ Adjusted}}),
  *     and the in memory editable state is being updated
  *     (type: {{EdSt @@ Adjusted}}).
  *
  *   - From these values, the new in memory state (type {{St @@ Adjusted}})
  *     and a response for the client (type {{Res}}) together with
  *     an editing object to be stored on disk (type {{LoadEd}}) are
  *     created.
  *
  * Modifying and deleting existing data objects have similar workflows.
  * Several utility objects with their own utility types are necessary
  * to perform the tasks described above. In all three cases, the types should
  * suffice to document the expected behavior of the required functions:
  *
  *   {{val auth}} is the object used for authorized the creation, modification
  *   and deleting of data objects. It defines its own type aliases used
  *   for these operations.
  *
  *   {{val valid}} is used for validating data objects
  *
  *   {{val cud}} is used for adjusting data objects with information
  *   not specified by clients but generated by the server (IDs, timestamps,
  *   fingerprints)
  *
  *
  * A note on environment variables: Almost every piece of functionality
  * in this trait comes with its own environment type. While this makes
  * extracting these environments from the master environments {{Env}} and
  * {{EdSt}} somewhat cumbersome, it leads to functions with minimal dependencies
  * making it much easier to write unit tests for these functions.
  * Implementors, however, are free to always use the same type for all
  * environments. In our experience, this makes testing the behavior of
  * critical functions much more difficult.
  */
trait Editor {

  //----------------------------------------------------------------------
  //                             Types
  //----------------------------------------------------------------------
  
  /**
    * Type of errors returned by functions that could fail
    */
  type Err

  type DataE[A] = ErrNel[Err,A]

  type DataV[A] = ValNel[Err,A]
  
  /**
    * Main environment used in editing
    */
  type Env

  /**
    * Environment needed to create the result
    */
  type ResEnv

  /**
    * Id by which we can find a data object in its parent
    */
  type Id

  /**
    * Server state containing the data tree
    */
  type St

  /**
    * State mutated during editing
    */
  type EdSt

  /**
    * Path leading to a data object's parent
    */
  type ParentPath

  /**
    * Editing result being sent to the client
    */
  type Res

  /**
    * Data object as seen at the server
    */
  type Srv

  /**
    * A data object being added needs to have every field set.
    * Optional fields should be optional in the data object itself.
    */
  type Add

  /**
    * For a data object being modified, all fields are optional.
    */
  type Mod

  /**
    * Data object for adding as it is stored on disk
    */
  type SrvAdd

  /**
    * Data object for modifying as it is stored on disk
    */
  type SrvMod

  /**
    * Editing object as sent by client
    */
  final type Ed = Edit[Id,Add,Mod]

  /**
    * Editing object as stored on disk
    */
  final type LoadEd = Edit[Id @@ IsValid,SrvAdd @@ IsValid,SrvMod @@ IsValid]

  final type DB = Map[Id,Srv]

  //----------------------------------------------------------------------
  //                             Functions
  //----------------------------------------------------------------------

  /**
    * Error to be thrown if a user is not authorized to
    * perform a mutation
    */
  val unauthorized: Err

  /**
    * Provides functions used during the authorization step
    */
  val auth: Authorizer

  /**
    * Provides functions used during the validation step
    */
  val valid: Validator

  /**
    * Provides functions used to adjust / create certain values before
    * storing on disk.
    */
  val cud: CUD

  val toRes: (ResEnv, Srv, EdSt, LoadEd) ⇒ DataE[Res]

  /**
    * Looks up the editing environment
    */
  val edSt: (St,ParentPath) ⇒ DataE[EdSt]

  /**
    * Looks up the child
    *
    * There is an important law here:
    * If getSrv is succesfull, the Id of the returned Srv
    * (as returned by getId) must be equal to the original
    * Id:
    *
    *   forall (i: Id, e: EdSt) : getSrv(i,e).isRight ⇒
    *                             getId(getSrv(i,e).get) == i
    */
  val getSrv: (Id, EdSt) ⇒ DataE[Srv]

  /**
    * Modifies the environment
    *
    * One of the few methods that has to be tested rigorously
    */
  val edit: (Id, Option[Srv], EdSt) ⇒ EdSt

  val getSt: EdSt ⇒ St

  /**
    * Returns the Id of a data object.
    *
    * There is an important law here:
    * If getSrv is succesfull, the Id of the returned Srv
    * (as returned by getId) must be equal to the original
    * Id:
    *
    *   forall (i: Id, e: EdSt) : getSrv(i,e).isRight ⇒
    *                             getId(getSrv(i,e).get) == i
    */
  val getId: Srv ⇒ Id

  val envToSt: Env ⇒ St

  def envs(e: Env, edSt: EdSt): Envs

  final def srvSt(st: St, id: Id, p: ParentPath): DataE[(Srv,EdSt)] = for {
    e <- edSt(st, p)
    s <- getSrv(id, e)
  } yield s -> e

  //----------------------------------------------------------------------
  //                         Editing Data
  //----------------------------------------------------------------------

  final def fullEd(pp: ParentPath): (Env,Ed) ⇒ DataE[(St @@ Adjusted, LoadEd, Res)] = (le,e) ⇒ {
    val st = envToSt(le)
    for {
      es  <- edSt(st,pp)
      vs  =  envs(le,es)
      p   <- ed(st,vs,es,e)
      (st,s,lo) = p
      res <- toResTS(vs.res,s,st,lo)
    } yield (mapTagged(st)(getSt), lo, res)
  }

  final def ed(st: St, envs: Envs, es: EdSt, e: Ed): DataE[(EdSt @@ Adjusted,Srv @@ Adjusted, LoadEd)] = e match {
    case Add(a) ⇒ for {
      aa   <- auth.addTS(envs.aae,a)      // authorize:    Add @@ Authorized
      av   <- valid.addTS(envs.vae,aa)    // validate:     Add @@ IsValid
      sa   =  cud.addTS(envs.cae, av)     // create:       SrvAdd @@ Adjusted
      sr   =  cud.srvTS(sa)               // create:       Srv @@ Adjusted
      es2  = editT(sr)(es)                // adjust state: EdSt @@ Adjusted
    } yield (es2, sr, Add(sa))

    case Mod(i,m) ⇒ for {
      sr   <- getSrv(i,es)                // lookup state: Srv
      ma   <- auth.modTS(envs.ame,sr,m)   // authorize:    Mod @@ Authorized
      mv   <- valid.modTS(envs.vme,sr,ma) // validate:     Mod @@ IsValid
      ml   =  cud.modTS(envs.cme, mv)     // adjust mod:   SrvMod
      sr2  =  cud.adjTS(sr,ml)            // adjust srv:   Srv @@ Adjusted
      es2  =  editT(sr2)(es)
    } yield (es2, sr2, Mod(getValId(sr2), ml))

    case Del(i)  ⇒ for {
      sr   <- getSrv(i,es)                // lookup state: Srv
      ia   <- auth.delTS(envs.ade,sr,i)   // authorize:    Id @@ Authorized
      iv   <- valid.delTS(envs.vde,sr,ia) // validate:     Id @@ IsValid
      es2  =  del(iv, es)
    } yield (es2, doDel(sr,iv), Del(iv))
  }

  //----------------------------------------------------------------------
  //                         Loading Data
  //----------------------------------------------------------------------

  final def load(st: St, p: ParentPath, e: LoadEd): DataE[St @@ Adjusted] =
    e match {
      case Add(s)   ⇒ edSt(st,p) map addSt(s)
      case Del(i)   ⇒ srvSt(st,i,p) map { case (_,e) ⇒ delSt(i, e) }
      case Mod(i,m) ⇒ srvSt(st,i,p) map { case (s,e) ⇒ modSt(s, m)(e) }
    }

  //----------------------------------------------------------------------
  //                         Utility Functions
  //----------------------------------------------------------------------

  def mod[A](ap: Pure[A], ao: Option[A]): Pure[A] = ao.fold(ap)(Pure.apply)

  def changed[A:Eq](o: Pure[A], n: Option[A]): Boolean = n.exists(o.v =!= _)

  def same[A:Eq](o: Pure[A], n: Option[A]): Boolean = !changed(o,n)

  def uniqAdd[B,I:Eq,V:Eq](db: Map[I,B], v: Pure[V])(get: B ⇒ Pure[V])
    (err: (I,V) ⇒ Err): List[Err] =
    uniq(db, none, some(v.v))(b ⇒ some(get(b).v))(err)

  def uniqAddO[B,I:Eq,V:Eq](db: Map[I,B], v: Pure[Option[V]])
    (get: B ⇒ Pure[Option[V]])(err: (I,V) ⇒ Err): List[Err] =
    uniq(db, none, v.v)(b ⇒ get(b).v)(err)

  def uniqMod[B,I:Eq,V:Eq](db: Map[I,B], id: I, v: Option[V])(get: B ⇒ Pure[V])
    (err: (I,V) ⇒ Err): List[Err] =
    uniq(db, some(id), v)(b ⇒ some(get(b).v))(err)

  def uniqModO[B,I:Eq,V:Eq](db: Map[I,B], id: I, v: Option[Option[V]])
    (get: B ⇒ Pure[Option[V]])(err: (I,V) ⇒ Err): List[Err] =
    uniq(db, some(id), v.flatten)(b ⇒ get(b).v)(err)

  def uniq[B,I:Eq,V:Eq](db: Map[I,B], id: Option[I], ov: Option[V])
    (get: B ⇒ Option[V])(err: (I,V) ⇒ Err): List[Err] = for {
      v     <- ov.toList
      (i,b) <- db.toList
      if (!id.exists(i === _) && get(b).exists(v === _))
    } yield err(i,v)

  private def getValId(s: Srv @@ Adjusted): Id @@ IsValid =
    dotag(getId(s))

  private def editT(s: Srv @@ Adjusted)(e: EdSt): EdSt @@ Adjusted =
    dotag(edit(getValId(s), some(s), e))

  private def modSt(s: Srv, m: SrvMod @@ IsValid)(e: EdSt): St @@ Adjusted =
    mapTagged(editT(cud.adjTS(s,m))(e))(getSt)

  private def addSt(s: SrvAdd @@ IsValid)(e: EdSt): St @@ Adjusted =
    mapTagged(editT(cud srvTS s)(e))(getSt)

  private def del(id: Id @@ IsValid, e: EdSt): EdSt @@ Adjusted =
    dotag(edit(id, None, e))

  private def delSt(id: Id @@ IsValid, e: EdSt): St @@ Adjusted =
    mapTagged(del(id, e))(getSt)

  private def doDel(s: Srv, i: Id @@ IsValid): Srv @@ Adjusted = dotag(s)

  private def toResTS(
    r: ResEnv,
    s: Srv @@ Adjusted,
    e: EdSt @@ Adjusted,
    l: LoadEd
  ): DataE[Res] = toRes(r, s, e, l)


  private def err[A,T](a: A, es: List[Err]): DataE[A @@ T] = es match {
    case Nil  ⇒ Right(dotag[A,T](a))
    case h::t ⇒ Left(Nel(h,t))
  }

  //----------------------------------------------------------------------
  //                          Create,Update,Delete
  //----------------------------------------------------------------------
  
  /**
    * Data type used to adjust data objects (creating IDs,
    * adding timestamps, calculating fingerprints) before storing
    * them on disk or in memory.
    *
    * Use CUDImpl to create instances of this data type.
    */
  sealed trait CUD {
    /**
      * Environment needed to adjust data when creating a new data object
      */
    type AddEnv

    /**
      * Environment needed to adjust data when modifying an existing
      * data object
      */
    type ModEnv

    /**
      * Adjusts data (for object creation)
      * sent from the client. Data thus generated is
      * persisted on disk.
      */
    val doAdd:  Add    ⇒ AddEnv ⇒ SrvAdd

    /**
      * Adjusts data loaded from disk before storing in memory.
      * These adjustments are not persisted.
      */
    val toSrv:  SrvAdd ⇒ Srv

    /**
      * Adjusts data (for object modification) 
      * sent from the client. Data thus generated is
      * persisted on disk.
      */
    val adjMod: (ModEnv,Mod) ⇒ SrvMod

    /**
      * Mutates an in-memory data object from data loaded from disk
      */
    val doMod:  (Srv,SrvMod) ⇒ Srv

    final def addTS(e: AddEnv, a: Add @@ IsValid): SrvAdd @@ IsValid =
      mapTagged(a)(doAdd(_)(e))

    final def srvTS(a: SrvAdd @@ IsValid): Srv @@ Adjusted =
      dotag(toSrv(a))

    final def modTS(e: ModEnv, m: Mod @@ IsValid): SrvMod @@ IsValid =
      mapTagged(m)(adjMod(e,_))

    final def adjTS(s: Srv, m: SrvMod @@ IsValid): Srv @@ Adjusted =
      dotag(doMod(s,m))
  }

  case class CUDImpl[A,M](
    doAdd:  Add ⇒ A      ⇒ SrvAdd,
    toSrv:  SrvAdd       ⇒ Srv,
    adjMod: (M,Mod)      ⇒ SrvMod,
    doMod:  (Srv,SrvMod) ⇒ Srv,
  ) extends CUD{
    type AddEnv = A
    type ModEnv = M
  }

  //----------------------------------------------------------------------
  //                          Authorization
  //----------------------------------------------------------------------
  
  /**
    * Data type used during user authorization.
    *
    * Use AuthorizerImpl to create instances of this data type.
    */
  sealed trait Authorizer {
    /**
      * Environment needed for user authorization when creating a new data object
      */
    type AddEnv

    /**
      * Environment needed for user authorization when modifying an
      * existing data object
      */
    type ModEnv

    /**
      * Environment needed for user authorization when deleting a data object
      */
    type DelEnv

    /**
      * Authorized users before adding a new data object. Returns
      * a list containing all errors found. An empty list means that
      * the data provided is valid.
      */
    val add: (AddEnv,Add)     ⇒ List[Err]

    /**
      * Authorized users before modifying an existing data object. Returns
      * a list containing all errors found. An empty list means that
      * the data provided is valid.
      */
    val mod: (ModEnv,Srv,Mod) ⇒ List[Err]

    /**
      * Authorized users before deleting an existing data object. Returns
      * a list containing all errors found. An empty list means that
      * the data provided is valid.
      */
    val del: (DelEnv,Srv,Id)  ⇒ List[Err]

    final def addTS(e: AddEnv, a: Add): DataE[Add @@ Authorized] =
      err(a, add(e, a))

    final def modTS(e: ModEnv, s: Srv, m: Mod): DataE[Mod @@ Authorized] =
      err(m, mod(e, s, m))

    final def delTS(e: DelEnv, s: Srv, i: Id): DataE[Id @@ Authorized] =
      err(i, del(e, s, i))
  }

  case class AuthorizerImpl[A,M,D](
    add: (A,Add)     ⇒ List[Err],
    mod: (M,Srv,Mod) ⇒ List[Err],
    del: (D,Srv,Id)  ⇒ List[Err],
  ) extends Authorizer{
    type AddEnv = A
    type ModEnv = M
    type DelEnv = D
  }

  //----------------------------------------------------------------------
  //                          Validation
  //----------------------------------------------------------------------
  
  /**
    * Data type used during validation of editing requests.
    *
    * Use ValidatorImpl to create instances of this data type.
    */
  sealed trait Validator {
    /**
      * Environment needed for validation when creating a new data object
      */
    type AddEnv

    /**
      * Environment needed for validation when modifying an existing data object
      */
    type ModEnv

    /**
      * Environment needed for validation when deleting a data object
      */
    type DelEnv

    /**
      * Validates data for adding a new data object. Returns
      * a list containing all errors found. An empty list means that
      * the data provided is valid.
      */
    val add: (AddEnv,Add)     ⇒ List[Err]

    /**
      * Validates data for modifying an existing data object. Returns
      * a list containing all errors found. An empty list means that
      * the data provided is valid.
      */
    val mod: (ModEnv,Srv,Mod) ⇒ List[Err]

    /**
      * Validates data for deleting a data object. Returns
      * a list containing all errors found. An empty list means that
      * the data provided is valid.
      */
    val del: (DelEnv,Srv,Id)  ⇒ List[Err]

    final def addTS(e: AddEnv, a: Add @@ Authorized): DataE[Add @@ IsValid] =
      err(a, add(e, a))

    final def modTS(e: ModEnv, s: Srv, m: Mod @@ Authorized): DataE[Mod @@ IsValid] =
      err(m, mod(e, s, m))

    final def delTS(e: DelEnv, s: Srv, i: Id @@ Authorized): DataE[Id @@ IsValid] =
      err(i, del(e, s, i))
  }


  case class ValidatorImpl[A,M,D](
    add: (A,Add)     ⇒ List[Err],
    mod: (M,Srv,Mod) ⇒ List[Err],
    del: (D,Srv,Id)  ⇒ List[Err],
  ) extends Validator {
    type AddEnv = A
    type ModEnv = M
    type DelEnv = D
  }

  //----------------------------------------------------------------------
  //                          Environments
  //----------------------------------------------------------------------

  /**
    * Data type grouping all environments required during editing.
    */
  case class Envs(
    aae: auth.AddEnv,
    ame: auth.ModEnv,
    ade: auth.DelEnv,
    vae: valid.AddEnv,
    vme: valid.ModEnv,
    vde: valid.DelEnv,
    cae: cud.AddEnv,
    cme: cud.ModEnv,
    res: ResEnv,
  )
}


